import React, { useRef, useState, useLayoutEffect } from 'react';
import { withDefaultProps } from '../../utils/with-default-props';
import { withNativeProps } from '../../utils/native-props';
var classPrefix = "adm-ellipsis";
var defaultProps = {
  direction: 'end',
  rows: 1
};
export var Ellipsis = withDefaultProps(defaultProps)(function (props) {
  var originRef = useRef(null);

  var _useState = useState(''),
      ellipsised = _useState[0],
      setEllipsised = _useState[1];

  useLayoutEffect(function () {
    var origin = originRef.current;
    if (!origin) return;
    var originStyle = window.getComputedStyle(origin);
    var container = document.createElement('div');
    var styleNames = Array.prototype.slice.apply(originStyle);
    styleNames.forEach(function (name) {
      container.style.setProperty(name, originStyle.getPropertyValue(name));
    });
    container.style.position = 'fixed';
    container.style.left = '999999px';
    container.style.top = '999999px';
    container.style.zIndex = '-1000';
    container.style.height = 'auto';
    container.style.minHeight = 'auto';
    container.style.maxHeight = 'auto';
    container.style.textOverflow = 'clip';
    container.style.whiteSpace = 'normal';
    container.style.webkitLineClamp = 'unset';
    container.style.webkitBoxOrient = 'unset';
    container.style.display = 'block';
    var lineHeight = pxToNumber(originStyle.lineHeight);
    var maxHeight = Math.floor(lineHeight * props.rows + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
    container.innerText = props.content;
    document.body.appendChild(container);

    if (container.offsetHeight <= maxHeight) {
      setEllipsised(props.content);
    } else {
      var check = function check(left, right) {
        if (right - left <= 1) {
          if (props.direction === 'end') {
            return props.content.slice(0, left) + '...';
          } else {
            return '...' + props.content.slice(right, end);
          }
        }

        var middle = Math.round((left + right) / 2);

        if (props.direction === 'end') {
          container.innerText = props.content.slice(0, middle) + '...';
        } else {
          container.innerText = '...' + props.content.slice(middle, end);
        }

        if (container.offsetHeight <= maxHeight) {
          if (props.direction === 'end') {
            return check(middle, right);
          } else {
            return check(left, middle);
          }
        } else {
          if (props.direction === 'end') {
            return check(left, middle);
          } else {
            return check(middle, right);
          }
        }
      };

      var checkMiddle = function checkMiddle(leftPart, rightPart) {
        if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
          return props.content.slice(0, leftPart[0]) + '...' + props.content.slice(rightPart[1], end);
        }

        var leftPartMiddle = Math.floor((leftPart[0] + leftPart[1]) / 2);
        var rightPartMiddle = Math.floor((rightPart[0] + rightPart[1]) / 2);
        container.innerText = props.content.slice(0, leftPartMiddle) + '...' + props.content.slice(rightPartMiddle, end);

        if (container.offsetHeight <= maxHeight) {
          return checkMiddle([leftPartMiddle, leftPart[1]], [rightPart[0], rightPartMiddle]);
        } else {
          return checkMiddle([leftPart[0], leftPartMiddle], [rightPartMiddle, rightPart[1]]);
        }
      };

      var end = props.content.length;
      var middle = Math.floor((0 + end) / 2);
      setEllipsised(props.direction === 'middle' ? checkMiddle([0, middle], [middle, end]) : check(0, end));
    }

    document.body.removeChild(container);
  }, [props.content, props.rows, props.direction]);
  return withNativeProps(props, /*#__PURE__*/React.createElement("div", {
    ref: originRef,
    className: classPrefix
  }, ellipsised));
});

function pxToNumber(value) {
  if (!value) return 0;
  var match = value.match(/^\d*(\.\d*)?/);
  return match ? Number(match[0]) : 0;
}